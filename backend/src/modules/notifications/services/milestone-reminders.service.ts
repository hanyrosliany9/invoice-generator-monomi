import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../shared/database/prisma.service';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Cron, CronExpression } from '@nestjs/schedule';
import dayjs from 'dayjs';

interface MilestoneReminder {
  type: 'MILESTONE_DUE_SOON' | 'MILESTONE_OVERDUE' | 'PAYMENT_OVERDUE' | 'MILESTONE_COMPLETED' | 'REVENUE_RECOGNITION_REQUIRED';
  paymentMilestoneId?: string;
  projectMilestoneId?: string;
  invoiceId?: string;
  message: string;
  daysUntilDue?: number;
  recipient: string;
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  createdAt: Date;
}

@Injectable()
export class MilestoneRemindersService {
  private readonly logger = new Logger(MilestoneRemindersService.name);

  constructor(
    private prisma: PrismaService,
    private eventEmitter: EventEmitter2
  ) {}

  /**
   * Check for milestones due soon (7 days before due date)
   * Runs daily at 6 AM
   */
  @Cron(CronExpression.EVERY_DAY_AT_6AM)
  async checkMilestonesDueSoon(): Promise<void> {
    try {
      this.logger.debug('Checking for milestones due soon...');

      const sevenDaysFromNow = dayjs().add(7, 'days').toDate();
      const tomorrow = dayjs().add(1, 'day').startOf('day').toDate();

      const upcomingMilestones = await this.prisma.paymentMilestone.findMany({
        where: {
          dueDate: {
            gte: tomorrow,
            lte: sevenDaysFromNow
          },
          isInvoiced: false
        },
        include: {
          quotation: {
            include: {
              client: true,
              createdByUser: true
            }
          }
        }
      });

      for (const milestone of upcomingMilestones) {
        const daysUntilDue = dayjs(milestone.dueDate).diff(dayjs(), 'days');

        const reminder: MilestoneReminder = {
          type: 'MILESTONE_DUE_SOON',
          paymentMilestoneId: milestone.id,
          message: `Milestone "${milestone.name}" is due in ${daysUntilDue} days (${dayjs(milestone.dueDate).format('DD/MM/YYYY')})`,
          daysUntilDue,
          recipient: milestone.quotation.createdByUser?.email || 'admin@monomi.id',
          priority: daysUntilDue <= 2 ? 'HIGH' : 'MEDIUM',
          createdAt: new Date()
        };

        await this.emitReminder(reminder);
      }

      this.logger.debug(`Checked ${upcomingMilestones.length} milestones due soon`);
    } catch (error) {
      this.logger.error('Error checking milestones due soon:', error);
    }
  }

  /**
   * Check for overdue milestones (milestone passed due date but not invoiced)
   * Runs daily at 8 AM
   */
  @Cron(CronExpression.EVERY_DAY_AT_8AM)
  async checkOverdueMilestones(): Promise<void> {
    try {
      this.logger.debug('Checking for overdue milestones...');

      const now = dayjs().startOf('day').toDate();

      const overdueMilestones = await this.prisma.paymentMilestone.findMany({
        where: {
          dueDate: {
            lt: now
          },
          isInvoiced: false
        },
        include: {
          quotation: {
            include: {
              client: true,
              createdByUser: true
            }
          }
        }
      });

      for (const milestone of overdueMilestones) {
        const daysPastDue = dayjs().diff(dayjs(milestone.dueDate), 'days');

        const reminder: MilestoneReminder = {
          type: 'MILESTONE_OVERDUE',
          paymentMilestoneId: milestone.id,
          message: `Milestone "${milestone.name}" is ${daysPastDue} days overdue. Invoice was not generated by due date (${dayjs(milestone.dueDate).format('DD/MM/YYYY')})`,
          daysUntilDue: -daysPastDue,
          recipient: milestone.quotation.createdByUser?.email || 'admin@monomi.id',
          priority: daysPastDue > 7 ? 'CRITICAL' : 'HIGH',
          createdAt: new Date()
        };

        await this.emitReminder(reminder);
      }

      this.logger.debug(`Checked ${overdueMilestones.length} overdue milestones`);
    } catch (error) {
      this.logger.error('Error checking overdue milestones:', error);
    }
  }

  /**
   * Check for overdue invoice payments
   * Runs daily at 9 AM
   */
  @Cron(CronExpression.EVERY_DAY_AT_9AM)
  async checkOverduePayments(): Promise<void> {
    try {
      this.logger.debug('Checking for overdue payments...');

      const now = dayjs().startOf('day').toDate();

      const overdueInvoices = await this.prisma.invoice.findMany({
        where: {
          dueDate: {
            lt: now
          },
          status: {
            in: ['SENT', 'PENDING_PAYMENT']
          }
        },
        include: {
          paymentMilestone: true,
          client: true,
          createdByUser: true,
          payments: {
            where: { status: 'CONFIRMED' }
          }
        }
      });

      for (const invoice of overdueInvoices) {
        // Calculate how much is still outstanding
        const totalPaid = invoice.payments.reduce((sum, p) => sum + Number(p.amount), 0);
        const outstanding = Number(invoice.totalAmount) - totalPaid;

        if (outstanding > 0) {
          const daysPastDue = dayjs().diff(dayjs(invoice.dueDate), 'days');

          const reminder: MilestoneReminder = {
            type: 'PAYMENT_OVERDUE',
            invoiceId: invoice.id,
            paymentMilestoneId: invoice.paymentMilestoneId || undefined,
            message: `Invoice #${invoice.invoiceNumber} is ${daysPastDue} days overdue. Outstanding amount: Rp ${outstanding.toLocaleString('id-ID')}`,
            daysUntilDue: -daysPastDue,
            recipient: invoice.createdByUser?.email || 'admin@monomi.id',
            priority: daysPastDue > 14 ? 'CRITICAL' : 'HIGH',
            createdAt: new Date()
          };

          await this.emitReminder(reminder);
        }
      }

      this.logger.debug(`Checked for ${overdueInvoices.length} potentially overdue invoices`);
    } catch (error) {
      this.logger.error('Error checking overdue payments:', error);
    }
  }

  /**
   * Check for project milestones marked as completed (should trigger revenue recognition)
   * Runs every 4 hours
   */
  @Cron('0 */4 * * *')
  async checkCompletedMilestones(): Promise<void> {
    try {
      this.logger.debug('Checking for completed project milestones...');

      const completedMilestones = await this.prisma.projectMilestone.findMany({
        where: {
          status: 'COMPLETED',
          journalEntryId: null // Not yet recognized in accounting
        },
        include: {
          project: true,
          createdByUser: true
        }
      });

      for (const milestone of completedMilestones) {
        const reminder: MilestoneReminder = {
          type: 'MILESTONE_COMPLETED',
          projectMilestoneId: milestone.id,
          message: `Project milestone "${milestone.name}" has been completed and is ready for revenue recognition`,
          recipient: milestone.createdByUser?.email || 'admin@monomi.id',
          priority: 'MEDIUM',
          createdAt: new Date()
        };

        await this.emitReminder(reminder);
      }

      this.logger.debug(`Checked ${completedMilestones.length} completed project milestones`);
    } catch (error) {
      this.logger.error('Error checking completed milestones:', error);
    }
  }

  /**
   * Check for PSAK 72 revenue recognition requirements
   * Runs daily at 10 AM
   */
  @Cron(CronExpression.EVERY_DAY_AT_10AM)
  async checkRevenueRecognitionRequirements(): Promise<void> {
    try {
      this.logger.debug('Checking for revenue recognition requirements...');

      // Find paid invoices that don't have corresponding revenue recognition
      const paidInvoices = await this.prisma.invoice.findMany({
        where: {
          status: 'PAID_OFF'
        },
        include: {
          projectMilestone: {
            include: {
              journalEntries: true
            }
          },
          createdByUser: true
        }
      });

      for (const invoice of paidInvoices) {
        // Check if revenue has been recognized
        if (invoice.projectMilestone && invoice.projectMilestone.journalEntries.length === 0) {
          const reminder: MilestoneReminder = {
            type: 'REVENUE_RECOGNITION_REQUIRED',
            invoiceId: invoice.id,
            projectMilestoneId: invoice.projectMilestoneId || undefined,
            message: `Invoice #${invoice.invoiceNumber} has been paid but revenue has not been recognized (PSAK 72 compliance required)`,
            recipient: invoice.createdByUser?.email || 'admin@monomi.id',
            priority: 'HIGH',
            createdAt: new Date()
          };

          await this.emitReminder(reminder);
        }
      }

      this.logger.debug('Checked revenue recognition requirements');
    } catch (error) {
      this.logger.error('Error checking revenue recognition requirements:', error);
    }
  }

  /**
   * Emit reminder event for notification system to handle
   */
  private async emitReminder(reminder: MilestoneReminder): Promise<void> {
    try {
      // Emit event for real-time notifications
      this.eventEmitter.emit('milestone.reminder', reminder);

      // Store reminder in database for audit trail
      await this.storeMilestoneReminder(reminder);

      // Emit specific event based on type
      switch (reminder.type) {
        case 'MILESTONE_DUE_SOON':
          this.eventEmitter.emit('milestone.due-soon', reminder);
          break;
        case 'MILESTONE_OVERDUE':
          this.eventEmitter.emit('milestone.overdue', reminder);
          break;
        case 'PAYMENT_OVERDUE':
          this.eventEmitter.emit('payment.overdue', reminder);
          break;
        case 'MILESTONE_COMPLETED':
          this.eventEmitter.emit('milestone.completed', reminder);
          break;
        case 'REVENUE_RECOGNITION_REQUIRED':
          this.eventEmitter.emit('revenue-recognition.required', reminder);
          break;
      }

      this.logger.debug(`Emitted reminder: ${reminder.type} for ${reminder.recipient}`);
    } catch (error) {
      this.logger.error('Error emitting reminder:', error);
    }
  }

  /**
   * Store reminder in database for audit trail and notification history
   */
  private async storeMilestoneReminder(reminder: MilestoneReminder): Promise<void> {
    try {
      // Note: This assumes a MilestoneReminder table exists in the database
      // If not, you can store this in an AuditLog or Notification table instead
      await this.prisma.$executeRawUnsafe(`
        INSERT INTO milestone_reminders (
          type,
          payment_milestone_id,
          project_milestone_id,
          invoice_id,
          message,
          days_until_due,
          recipient,
          priority,
          created_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9
        )
      `,
        reminder.type,
        reminder.paymentMilestoneId || null,
        reminder.projectMilestoneId || null,
        reminder.invoiceId || null,
        reminder.message,
        reminder.daysUntilDue || null,
        reminder.recipient,
        reminder.priority,
        reminder.createdAt
      );
    } catch (error) {
      // If table doesn't exist, just log the reminder
      this.logger.warn('Could not store reminder in database:', error);
    }
  }

  /**
   * Get all reminders for a user
   */
  async getUserReminders(userId: string, limit: number = 20): Promise<MilestoneReminder[]> {
    try {
      const user = await this.prisma.user.findUnique({
        where: { id: userId }
      });

      if (!user) {
        return [];
      }

      // This would query from your reminders table
      // For now, return empty array as placeholder
      return [];
    } catch (error) {
      this.logger.error('Error getting user reminders:', error);
      return [];
    }
  }

  /**
   * Mark reminder as read
   */
  async markReminderAsRead(reminderId: string): Promise<void> {
    try {
      // Update reminder status in database
      this.logger.debug(`Marked reminder ${reminderId} as read`);
    } catch (error) {
      this.logger.error('Error marking reminder as read:', error);
    }
  }

  /**
   * Dismiss/snooze reminder
   */
  async snoozeReminder(reminderId: string, snoozeMinutes: number = 60): Promise<void> {
    try {
      this.logger.debug(`Snoozed reminder ${reminderId} for ${snoozeMinutes} minutes`);
    } catch (error) {
      this.logger.error('Error snoozing reminder:', error);
    }
  }

  /**
   * Get summary of pending actions
   */
  async getSummary() {
    try {
      const today = dayjs().startOf('day').toDate();
      const sevenDaysFromNow = dayjs().add(7, 'days').toDate();

      // Milestones due in next 7 days
      const upcomingMilestones = await this.prisma.paymentMilestone.count({
        where: {
          dueDate: {
            gte: today,
            lte: sevenDaysFromNow
          },
          isInvoiced: false
        }
      });

      // Overdue milestones
      const overdueMilestones = await this.prisma.paymentMilestone.count({
        where: {
          dueDate: {
            lt: today
          },
          isInvoiced: false
        }
      });

      // Overdue invoices
      const overdueInvoices = await this.prisma.invoice.count({
        where: {
          dueDate: {
            lt: today
          },
          status: {
            in: ['SENT', 'PENDING_PAYMENT']
          }
        }
      });

      return {
        upcomingMilestones,
        overdueMilestones,
        overdueInvoices,
        totalPendingActions: upcomingMilestones + overdueMilestones + overdueInvoices
      };
    } catch (error) {
      this.logger.error('Error getting summary:', error);
      return {
        upcomingMilestones: 0,
        overdueMilestones: 0,
        overdueInvoices: 0,
        totalPendingActions: 0
      };
    }
  }
}
